{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://polotai-i-hw3-refactor/./src/utils.ts","webpack://polotai-i-hw3-refactor/./src/enums/audio-defaults.enum.ts","webpack://polotai-i-hw3-refactor/./src/audio.ts","webpack://polotai-i-hw3-refactor/./src/classes/CircleSprite.ts","webpack://polotai-i-hw3-refactor/./src/classes/BarSprite.ts","webpack://polotai-i-hw3-refactor/./src/canvas.ts","webpack://polotai-i-hw3-refactor/./src/main.ts","webpack://polotai-i-hw3-refactor/./src/loader.ts"],"sourcesContent":["//Creates a color based on the passed in rgba values\r\nconst makeColor = (red: number, green: number, blue: number, alpha: number = 1) => {\r\n    return `rgba(${red},${green},${blue},${alpha})`;\r\n};\r\n\r\n//Generates a random number between the min and max\r\nconst getRandom = (min: number, max: number) => {\r\n    return Math.random() * (max - min) + min;\r\n};\r\n\r\n//Generates a random color \r\nconst getRandomColor = () => {\r\n    const floor: number = 35; // so that colors are not too bright or too dark \r\n    const getByte = () => getRandom(floor, 255 - floor);\r\n    return `rgba(${getByte()},${getByte()},${getByte()},1)`;\r\n};\r\n\r\n//Creates a gradient based on the passed in color and percent values\r\nconst getLinearGradient = (ctx:CanvasRenderingContext2D, startX: number, startY: number, endX: number, endY: number, colorStops: any) => {\r\n    let lg = ctx.createLinearGradient(startX, startY, endX, endY);\r\n    for (let stop of colorStops) {\r\n        lg.addColorStop(stop.percent, stop.color);\r\n    }\r\n    return lg;\r\n};\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\r\n//Sets the canvas to full screen\r\nconst goFullscreen = (element: HTMLCanvasElement) => {\r\n    if (element.requestFullscreen) {\r\n        element.requestFullscreen();\r\n    } else if (element.requestFullscreen) {\r\n        element.requestFullscreen();\r\n    } else if (element.requestFullscreen) { // camel-cased 'S' was changed to 's' in spec\r\n        element.requestFullscreen();\r\n    } else if (element.requestFullscreen) {\r\n        element.requestFullscreen();\r\n    }\r\n    // .. and do nothing if the method is not supported\r\n};\r\n\r\nexport { makeColor, getRandomColor, getLinearGradient, goFullscreen };","export enum defaults {\r\n    gain = .5,\r\n    numSamples = 256\r\n};","// 1 - our WebAudio context, **we will export and make this public at the bottom of the file**\r\nlet audioCtx:AudioContext;\r\n\r\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\r\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\r\nlet element:HTMLAudioElement, sourceNode: MediaElementAudioSourceNode, analyserNode: AnalyserNode, gainNode: GainNode, highShelfBiquadFilter: BiquadFilterNode, lowShelfBiquadFilter: BiquadFilterNode, distortionFilter: WaveShaperNode;\r\n\r\n// 3 - here we are faking an enumeration\r\nimport {defaults} from './enums/audio-defaults.enum';\r\n\r\n// 4 - create a new array of 8-bit integers (0-255)\r\n// this is a typed array to hold the audio frequency data\r\n\r\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\r\nconst setupWebaudio = (filePath: string) => {\r\n    // 1 - The || is because WebAudio has not been standardized across browsers yet\r\n    const AudioContext = window.AudioContext;\r\n    audioCtx = new AudioContext();\r\n\r\n    // 2 - this creates an <audio> element\r\n    element = new Audio();\r\n\r\n    // 3 - have it point at a sound file\r\n    loadSoundFile(filePath);\r\n\r\n    // 4 - create an a source node that points at the <audio> element\r\n    sourceNode = audioCtx.createMediaElementSource(element);\r\n\r\n    // 5 - create an analyser node\r\n    analyserNode = audioCtx.createAnalyser(); // note the UK spelling of \"Analyser\"\r\n\r\n    /*\r\n    // 6\r\n    We will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\n    across the sound spectrum.\r\n\r\n    If DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\n    the third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\n    the amplitude of that frequency.\r\n    */\r\n\r\n    // fft stands for Fast Fourier Transform\r\n    analyserNode.fftSize = defaults.numSamples;\r\n\r\n    // 7 - create a gain (volume) node\r\n    gainNode = audioCtx.createGain();\r\n    gainNode.gain.value = defaults.gain;\r\n\r\n    // 8 - create the treble node\r\n    highShelfBiquadFilter = audioCtx.createBiquadFilter();\r\n    highShelfBiquadFilter.type = \"highshelf\";\r\n\r\n    // 9 - create the bass node\r\n    lowShelfBiquadFilter = audioCtx.createBiquadFilter();\r\n    lowShelfBiquadFilter.type = \"lowshelf\";\r\n\r\n    // 10 - create the distortion node\r\n    distortionFilter = audioCtx.createWaveShaper();\r\n\r\n    // 11 - connect the nodes - we now have an audio graph\r\n    sourceNode.connect(analyserNode);\r\n    analyserNode.connect(gainNode);\r\n    gainNode.connect(highShelfBiquadFilter);\r\n    highShelfBiquadFilter.connect(lowShelfBiquadFilter);\r\n    lowShelfBiquadFilter.connect(distortionFilter);\r\n    distortionFilter.connect(audioCtx.destination);\r\n};\r\n\r\n//Loads a sound file from the provided filepath\r\nconst loadSoundFile = (filePath: string) => element.src = filePath;\r\n\r\n//Plays the current sound\r\nconst playCurrentSound = () => element.play();\r\n\r\n//Pauses the current sound\r\nconst pauseCurrentSound = () => element.pause();\r\n\r\n//Changes the volume based on the volume slider using the gain node\r\nconst setVolume = (value: string | number) => {\r\n    value = Number(value); // make sure that it's a Number rather than a String\r\n    gainNode.gain.value = value;\r\n};\r\n\r\n//Uses the highShelfBiquadFilter to create a Treble Filter\r\nconst toggleHighshelf = (highshelf: boolean) => { //treble\r\n    if (highshelf) {\r\n        highShelfBiquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        highShelfBiquadFilter.gain.setValueAtTime(25, audioCtx.currentTime);\r\n    } else {\r\n        highShelfBiquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n};\r\n\r\n//Uses the lowShelfBiquadFilter to create a Bass Filter\r\nconst toggleLowshelf = (lowshelf: boolean) => { //bass\r\n    if (lowshelf) {\r\n        lowShelfBiquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);\r\n        lowShelfBiquadFilter.gain.setValueAtTime(15, audioCtx.currentTime);\r\n    } else {\r\n        lowShelfBiquadFilter.gain.setValueAtTime(0, audioCtx.currentTime);\r\n    }\r\n};\r\n\r\n//Adds distortion to the audio via a distortion curve\r\nconst toggleDistortion = (distortion: boolean, distortionAmount: number) => {\r\n    if (distortion) {\r\n        distortionFilter.curve = null; // being paranoid and trying to trigger garbage collection\r\n        distortionFilter.curve = makeDistortionCurve(distortionAmount);\r\n    } else {\r\n        distortionFilter.curve = null;\r\n    }\r\n};\r\n\r\n//Creates a distortion curve using a distortion formula\r\n//from: https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\r\nconst makeDistortionCurve = (amount: number = 20) => {\r\n    if (amount == 0) return;\r\n    let n_samples = 256, curve = new Float32Array(n_samples);\r\n    for (let i = 0; i < n_samples; ++i) {\r\n        let x = i * 2 / n_samples - 1;\r\n        //curve[i] = -(Math.PI + 100 * x/2) / (Math.PI + 50 * Math.abs(x)) * amount;\r\n        //curve[i] = (Math.PI + (amount * 2)) * x / (Math.PI + amount * Math.abs(x));\r\n        curve[i] = (Math.PI + 100 * x / 2) / (Math.PI + 100 * Math.abs(x) * amount);\r\n        //curve[i] = x * Math.sin(x) * amount/5;\r\n        //curve[i] = (x * 5 + Math.random() * 2 - 1);\r\n    }\r\n    return curve;\r\n};\r\n\r\nexport { audioCtx, setupWebaudio, playCurrentSound, pauseCurrentSound, loadSoundFile, setVolume, analyserNode, toggleHighshelf, toggleLowshelf, toggleDistortion };","//Creates a circle sprite, which can change it's size and color based on \r\n//passed in audio data\r\nexport default class CircleSprite {\r\n    maxRadius: number;\r\n    circleRadius: number;\r\n    fillStyle: string;\r\n    radiusScale: number;\r\n    //Sets the initial values for the circle\r\n    constructor(maxRadius: number, radiusScale: number) {\r\n        this.maxRadius = maxRadius;\r\n        this.circleRadius = maxRadius;\r\n        this.fillStyle = \"black\";\r\n        this.radiusScale = radiusScale;\r\n    }\r\n\r\n    //Updates the size and color of the circle based on the passed in audio data\r\n    update(audioData: number) {\r\n        this.circleRadius = (audioData / 255) * this.maxRadius;\r\n        this.fillStyle = `rgb(${audioData},${audioData - 128},${255 - audioData})`;\r\n    }\r\n\r\n    //Draws the circle with the new data from update\r\n    draw(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number) {\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.arc(canvasWidth / 2, canvasHeight / 2, this.circleRadius * this.radiusScale, 0, 2 * Math.PI, false);\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.fill();\r\n        ctx.closePath();\r\n        ctx.restore();\r\n    }\r\n}","//Creates a bar sprite, which can change it's size and color based on \r\n//passed in audio data\r\nexport default class BarSprite {\r\n    barWidth: number;\r\n    maxBarHeight: number;\r\n    padding: number;\r\n    fillStyle: string;\r\n    percent: number;\r\n    //Sets the initial values for the bar\r\n    constructor(barWidth: number, maxBarHeight: number, padding: number) {\r\n        this.barWidth = barWidth;\r\n        this.maxBarHeight = maxBarHeight;\r\n        this.padding = padding;\r\n        this.fillStyle = \"black\";\r\n        this.percent = 0;\r\n    }\r\n\r\n    //Updates the size and color of the bar based on the passed in audio data\r\n    update(audioData: number) {\r\n        this.percent = audioData / 255;\r\n        this.percent = this.percent < 0.2 ? .02 : this.percent; //sets a minimum percent size, so bars are always visible\r\n        this.fillStyle = `rgb(${audioData},${audioData - 128},${255 - audioData})`;\r\n    }\r\n\r\n    //Draws the bar with the new data from update\r\n    draw(ctx: CanvasRenderingContext2D) {\r\n        ctx.save();\r\n        ctx.scale(1, -1);\r\n        ctx.fillStyle = this.fillStyle;\r\n        ctx.fillRect(0, 0, this.barWidth, this.maxBarHeight * this.percent);\r\n        ctx.restore();\r\n    }\r\n}","/*\r\n    The purpose of this file is to take in the analyser node and a <canvas> element: \r\n      - the module will create a drawing context that points at the <canvas> \r\n      - it will store the reference to the analyser node\r\n      - in draw(), it will loop through the data in the analyser node\r\n      - and then draw something representative on the canvas\r\n      - maybe a better name for this file/module would be *visualizer.js* ?\r\n*/\r\n\r\n//import * as utils from './utils.js';\r\nimport CircleSprite from './classes/CircleSprite';\r\nimport BarSprite from './classes/BarSprite';\r\nimport { DrawParams } from './interfaces/drawParams.interface';\r\n\r\nlet ctx:CanvasRenderingContext2D, canvasWidth:number, canvasHeight:number, analyserNode:AnalyserNode, audioData: Uint8Array, vinyl: HTMLImageElement;\r\nlet vinylRotation:number = 1;\r\n\r\nlet circleSprites:CircleSprite[];\r\nlet barSprite:BarSprite;\r\n\r\n//Sets up the canvas, loads the record image, and creates the two sprites\r\nconst setupCanvas = (canvasElement: HTMLCanvasElement, analyserNodeRef: AnalyserNode) => {\r\n    // create drawing context\r\n    ctx = canvasElement.getContext(\"2d\");\r\n    canvasWidth = canvasElement.width;\r\n    canvasHeight = canvasElement.height;\r\n    // keep a reference to the analyser node\r\n    analyserNode = analyserNodeRef;\r\n    // this is the array where the analyser data will be stored\r\n    audioData = new Uint8Array(analyserNode.fftSize / 2);\r\n\r\n    //load record image\r\n    vinyl = new Image();\r\n    vinyl.src = \"./media/vinyl.jpg\";\r\n\r\n    circleSprites = [];\r\n\r\n    //The two sprites are handled differently. The Circles have three distinct\r\n    //sprites that each get updated, while the Bar only has one sprite that \r\n    //gets passed in new information and draw multiple times each time the \r\n    //draw method below gets called, as it didn't make sense to create a bunch of\r\n    //copies of the bar sprites, each just rotated a tiny bit. \r\n\r\n    //Create circle sprites\r\n    circleSprites.push(new CircleSprite(canvasHeight / 4, 0.75));\r\n    circleSprites.push(new CircleSprite(canvasHeight / 4, 0.50));\r\n    circleSprites.push(new CircleSprite(canvasHeight / 4, 0.25));\r\n\r\n    //Create bar sprite\r\n    barSprite = new BarSprite(15, 110, 2);\r\n};\r\n\r\n//Draws the circles and bars using the audio data from the analyzer node, as well as\r\n//rotating the record image. \r\nconst draw = (params:DrawParams) => {\r\n    // 1 - populate the audioData array with the frequency data from the analyserNode\r\n    // notice these arrays are passed \"by reference\" \r\n    if (params.useTimeDomain) {\r\n        analyserNode.getByteTimeDomainData(audioData); // waveform data\r\n    }\r\n    else {\r\n        analyserNode.getByteFrequencyData(audioData);\r\n    }\r\n\r\n    // 2 - draw background\r\n    ctx.save();\r\n    ctx.fillStyle = \"#eef6fc\";\r\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\r\n    ctx.restore();\r\n\r\n    ctx.save();\r\n    ctx.translate(canvasWidth / 2, canvasHeight / 2);\r\n    ctx.rotate(vinylRotation);\r\n    ctx.scale(0.5, 0.5);\r\n    ctx.drawImage(vinyl, -vinyl.width / 2, -vinyl.height / 2);\r\n    ctx.restore();\r\n\r\n    //Checks to see if the song is done or paused. If it is, it stops the record vinyl from rotating\r\n    if (calculateMean(audioData) > 1.0) {\r\n        vinylRotation += params.rotationChange;\r\n    }\r\n\r\n    // 3 - draw bars\r\n    if (params.showBars) {\r\n\r\n        ctx.save();\r\n\r\n        ctx.translate(canvasWidth / 2 - barSprite.barWidth / 2, canvasHeight / 2 - 77);\r\n\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            ctx.translate(barSprite.barWidth, 0);\r\n            ctx.rotate(Math.PI * 2 / 32);\r\n            barSprite.update(audioData[i]);\r\n            barSprite.draw(ctx);\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    // 4 - draw circles\r\n    if (params.showCircles) {\r\n        ctx.save();\r\n        ctx.globalAlpha = 0.5;\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            for (let j = 0; j < circleSprites.length; j++) {\r\n                circleSprites[j].update(audioData[i]);\r\n                circleSprites[j].draw(ctx, canvasWidth, canvasHeight);\r\n            }\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    // 5 - bitmap manipulation\r\n    let imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\r\n    let data = imageData.data;\r\n    let length = data.length;\r\n    let width = imageData.width; // not using here\r\n    // B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\r\n    for (let i = 0; i < length; i += 4) {\r\n        // C) randomly change every 20th pixel to green\r\n        if (params.showNoise && Math.random() < 0.05) {\r\n            // data[i] is the red channel\r\n            // data[i+1] is the green channel\r\n            // data[i+2] is the blue channel\r\n            // data[i+3] is the alpha channel\r\n            // zero out the red and green and blue channels\r\n            // make the red channel 100% red\r\n            data[i] = data[i + 1] = data[i + 2] = 0;\r\n            data[i + 1] = 255;\r\n        } // end if\r\n\r\n        //invert colors\r\n        if (params.showInvert) {\r\n            let red = data[i], green = data[i + 1], blue = data[i + 3];\r\n            data[i] = 255 - red; //set red\r\n            data[i + 1] = 255 - green; //set green\r\n            data[i + 2] = 255 - blue; //set blue\r\n            //data[i+3] is the alpha, but we are leaving that alone\r\n        }\r\n    } // end for\r\n\r\n    //emboss\r\n    //note: we are stepping through *each* sub-pixel\r\n    if (params.showEmboss) {\r\n        for (let i = 0; i < length; i++) {\r\n            if (i % 4 == 3) continue; //skips alpha channel\r\n            data[i] = 127 + 2 * data[i] - data[i + 4] - data[i + width * 4];\r\n        }\r\n    }\r\n\r\n    // D) copy image data back to canvas\r\n    ctx.putImageData(imageData, 0, 0);\r\n};\r\n\r\n//Calculates the mean of all of the audioData frequencies, in order\r\n//to see if the song is playing or not (if the mean is close to 0, the\r\n//song is likely ending or has ended/has been paused)\r\nconst calculateMean = (audioData: Uint8Array) => {\r\n    let total = 0;\r\n    for (let i = 0; i < audioData.length; i++) {\r\n        total += audioData[i];\r\n    }\r\n    return total / audioData.length;\r\n}\r\n\r\nexport { setupCanvas, draw };","/*\r\n    main.js is primarily responsible for hooking up the UI to the rest of the application \r\n    and setting up the main event loop\r\n*/\r\n\r\n// We will write the functions in this file in the traditional ES5 way\r\n// In this instance, we feel the code is more readable if written this way\r\n// If you want to re-write these as ES6 arrow functions, to be consistent with the other files, go ahead!\r\n\r\nimport * as utils from './utils';\r\nimport * as audio from './audio';\r\nimport * as canvas from './canvas';\r\nimport { DrawParams } from './interfaces/drawParams.interface';\r\n\r\nconst drawParams:DrawParams = {\r\n    useTimeDomain: false,\r\n    rotationChange: 0.0,\r\n    showBars: true,\r\n    showCircles: true,\r\n    showNoise: false,\r\n    showInvert: false,\r\n    showEmboss: false\r\n};\r\n\r\nlet highshelf: boolean, lowshelf: boolean, distortion: boolean = false;\r\nlet distortionAmount: number = 20;\r\nlet fps: number = 60;\r\n\r\nconst DEFAULTS = {\r\n    sound1: \"\"\r\n};\r\n\r\n//Calls the JSON loading function when the page loads\r\nconst init = () => loadJsonXHR();\r\n\r\n//Loads the JSON file, which contains the title of the page song filepaths, \r\n//song names, and the default song\r\nconst loadJsonXHR = () => {\r\n    const url = \"./data/av-data.JSON\";\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.onload = (e) => {\r\n        //console.log(`In onload - HTTP Status Code = ${e.target.status}`);\r\n        let json: { filepaths: any; songnames: any; defaultsong: string; title: string; };\r\n        try {\r\n            const target = e.target as any;\r\n            json = JSON.parse(target.responseText);\r\n        }\r\n        catch {\r\n            console.log(\"JSON parsing failed\")\r\n            return;\r\n        }\r\n\r\n        //Sets the song names and filepaths\r\n        let filpathsMap = json.filepaths;\r\n        let tracksMap = json.songnames;\r\n        let dropdown = document.querySelector(\"#track-select\") as HTMLSelectElement;\r\n\r\n        for (let i = 0; i < filpathsMap.length; i++) {\r\n            //html += `<options value=\"${filpathsMap[i]}\">${tracksMap[i]}</option`;\r\n            let option = document.createElement(\"option\");\r\n            option.text = tracksMap[i];\r\n            option.value = filpathsMap[i];\r\n            dropdown.add(option);\r\n        }\r\n\r\n        //Loads the default song, and the title of the webpage from the JSON file\r\n        DEFAULTS.sound1 = json.defaultsong;\r\n        document.title = json.title;\r\n        document.querySelector(\"h1\").innerHTML = json.title;\r\n\r\n        //Sets up the audio and canvas after all of the JSON finishs loading \r\n        audio.setupWebaudio(DEFAULTS.sound1);\r\n        let canvasElement = document.querySelector(\"canvas\"); // hookup <canvas> element\r\n        setupUI(canvasElement);\r\n        canvas.setupCanvas(canvasElement, audio.analyserNode);\r\n        loop();\r\n    };\r\n    //xhr.onerror = e => { console.log(`In onerror - HTTP Status Code = ${e.target.status}`); };\r\n    xhr.open(\"GET\", url);\r\n    xhr.send();\r\n};\r\n\r\n//Sets up all of the checkboxes, sliders, and file upload\r\nconst setupUI = (canvasElement: HTMLCanvasElement) => {\r\n    // A - hookup fullscreen button\r\n    const fsButton = document.querySelector(\"#btn-fs\") as HTMLButtonElement;\r\n    const playButton = document.querySelector(\"#btn-play\") as HTMLButtonElement;\r\n\r\n    // add .onclick event to button\r\n    fsButton.onclick = e => {\r\n        //console.log(\"goFullscreen() called\");\r\n        utils.goFullscreen(canvasElement);\r\n    };\r\n\r\n    playButton.onclick = e => {\r\n        //console.log(`audioCtx.state before = ${audio.audioCtx.state}`);\r\n\r\n        const target = e.target as HTMLInputElement;\r\n        //check if the context is suspended (autoplay policy)\r\n        if (audio.audioCtx.state == \"suspended\") {\r\n            audio.audioCtx.resume();\r\n        }\r\n        //console.log(`audioCtx.state after = ${audio.audioCtx.state}`);\r\n        if (target.dataset.playing == \"no\") {\r\n            //if the track is currently paused, play it\r\n            audio.playCurrentSound();\r\n            target.dataset.playing = \"yes\"; //our CSS will set the text to \"Pause\"\r\n            drawParams.rotationChange = 0.01;\r\n        }\r\n        else { //if the track is playing, pause it\r\n            audio.pauseCurrentSound();\r\n            target.dataset.playing = \"no\"; //our CSS will set the text to \"Play\"\r\n            drawParams.rotationChange = 0.0;\r\n        }\r\n    }\r\n\r\n    // Hook up volume slider and label\r\n    let volumeSlider = document.querySelector(\"#volume-slider\") as HTMLInputElement;\r\n    let volumeLabel = document.querySelector(\"#volume-label\") as HTMLLabelElement;\r\n\r\n    //add .oninput event to slider\r\n    volumeSlider.oninput = e => {\r\n        //set the gain\r\n        const target = e.target as HTMLInputElement;\r\n        audio.setVolume(target.value);\r\n        //update the label to match the value of the slider\r\n        volumeLabel.innerHTML = (Math.round((((Number)(target.value)) / 2 * 100))).toString();\r\n    };\r\n\r\n    //set value of label to match initial value of slider\r\n    volumeSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n    //hookup track <select>\r\n    let trackSelect = document.querySelector(\"#track-select\") as HTMLInputElement;\r\n    //add .onchange event to <select>\r\n    trackSelect.onchange = e => {\r\n        const target = e.target as HTMLInputElement;\r\n        audio.loadSoundFile(target.value);\r\n        //pause the current track if it is playing\r\n        if (playButton.dataset.playing == \"yes\") {\r\n            playButton.dispatchEvent(new MouseEvent(\"click\"));\r\n        }\r\n    };\r\n\r\n    //set up checkboxes\r\n    (document.querySelector(\"#bars-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.showBars = target.checked; }\r\n    (document.querySelector(\"#circles-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.showCircles = target.checked; }\r\n    (document.querySelector(\"#noise-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.showNoise = target.checked; }\r\n    (document.querySelector(\"#invert-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.showInvert = target.checked; }\r\n    (document.querySelector(\"#emboss-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.showEmboss = target.checked; }\r\n    (document.querySelector(\"#domain-cb\") as HTMLInputElement).onchange = e => { const target = e.target as HTMLInputElement; drawParams.useTimeDomain = target.checked; }\r\n\r\n    // FILE UPLOAD\r\n\r\n    (document.querySelector(\"#upload\") as HTMLInputElement).onchange = (e) => {\r\n        const target = e.target as HTMLInputElement;\r\n        const files = target.files;\r\n        //document.querySelector(\"audio\").src = URL.createObjectURL(files[0]);\r\n        audio.loadSoundFile(URL.createObjectURL(files[0]));\r\n        //pause the current track if it is playing\r\n        if (playButton.dataset.playing == \"yes\") {\r\n            playButton.dispatchEvent(new MouseEvent(\"click\"));\r\n        }\r\n    };\r\n\r\n    //SOUND NODES/FILTERS SETUP\r\n\r\n    // I. set the initial state of the high shelf checkbox\r\n    (document.querySelector('#cb-highshelf') as HTMLInputElement).checked = highshelf; // `highshelf` is a boolean we will declare in a second\r\n\r\n    // II. change the value of `highshelf` every time the high shelf checkbox changes state\r\n    (document.querySelector('#cb-highshelf') as HTMLInputElement).onchange = e => {\r\n        const target = e.target as HTMLInputElement;\r\n        highshelf = target.checked;\r\n        audio.toggleHighshelf(highshelf); // turn on or turn off the filter, depending on the value of `highshelf`!\r\n    };\r\n\r\n    // III. when the app starts up, turn on or turn off the filter, depending on the value of `highshelf`!\r\n    audio.toggleHighshelf(highshelf);\r\n\r\n    // IV. set the initial state of the low shelf checkbox\r\n    (document.querySelector('#cb-lowshelf') as HTMLInputElement).checked = lowshelf; // `highshelf` is a boolean we will declare in a second\r\n\r\n    // V. change the value of `lowshelf` every time the low shelf checkbox changes state\r\n    (document.querySelector('#cb-lowshelf') as HTMLInputElement).onchange = e => {\r\n        const target = e.target as HTMLInputElement;\r\n        lowshelf = target.checked;\r\n        audio.toggleLowshelf(lowshelf); // turn on or turn off the filter, depending on the value of `highshelf`!\r\n    };\r\n\r\n    // VI. when the app starts up, turn on or turn off the filter, depending on the value of `lowshelf`!\r\n    audio.toggleLowshelf(lowshelf);\r\n\r\n    // VII. set up distortion event listener for checkbox\r\n    (document.querySelector('#cb-distortion') as HTMLInputElement).onchange = e => {\r\n        const target = e.target as HTMLInputElement;\r\n        distortion = target.checked;\r\n        audio.toggleDistortion(distortion, distortionAmount); // turn on or turn off the filter, depending on the value of `highshelf`!\r\n    };\r\n\r\n    // VIII. set up distortion slider and amount\r\n\r\n    let distortionLabel = document.querySelector(\"#distortion-label\") as HTMLLabelElement;\r\n\r\n    (document.querySelector('#slider-distortion') as HTMLInputElement).value = distortionAmount.toString();\r\n    (document.querySelector('#slider-distortion') as HTMLInputElement).oninput = e => {\r\n        const target = e.target as HTMLInputElement;\r\n        distortionAmount = Number(target.value);\r\n        audio.toggleDistortion(distortion, distortionAmount);\r\n        distortionLabel.innerHTML = (Math.round((Number(target.value) / 2 * 100))).toString();\r\n    };\r\n\r\n    //set value of label to match initial value of slider\r\n    document.querySelector('#slider-distortion').dispatchEvent(new Event(\"input\"));\r\n\r\n    audio.toggleDistortion(distortion, distortionAmount);\r\n}; // end setupUI\r\n\r\n//Starts the loop for drawing on the canvas\r\nconst loop = () => {\r\n    setTimeout(loop, 1000 / fps);\r\n    canvas.draw(drawParams);\r\n};\r\n\r\nexport { init };","import * as main from \"./main\";\r\n\r\n//Starts the init() function when the window loads\r\n//Loading of the image is done in canvas.js,\r\n//since it made sense to put it there\r\nwindow.onload = () => {\r\n    //console.log(\"window.onload called\");\r\n    // 1 - do preload here - load fonts, images, additional sounds, etc...\r\n\r\n    // 2 - start up app\r\n    main.init();\r\n}"],"names":["defaults","audioCtx","sourceNode","analyserNode","gainNode","highShelfBiquadFilter","lowShelfBiquadFilter","distortionFilter","loadSoundFile","filePath","src","toggleHighshelf","highshelf","frequency","setValueAtTime","currentTime","gain","toggleLowshelf","lowshelf","toggleDistortion","distortion","distortionAmount","curve","makeDistortionCurve","amount","Float32Array","i","x","Math","PI","abs","maxRadius","radiusScale","this","circleRadius","fillStyle","update","audioData","draw","ctx","canvasWidth","canvasHeight","save","beginPath","arc","fill","closePath","restore","barWidth","maxBarHeight","padding","percent","scale","fillRect","vinyl","circleSprites","barSprite","vinylRotation","drawParams","useTimeDomain","rotationChange","showBars","showCircles","showNoise","showInvert","showEmboss","DEFAULTS","sound1","setupUI","canvasElement","fsButton","document","querySelector","playButton","onclick","e","element","requestFullscreen","target","state","resume","dataset","playing","play","pause","volumeSlider","volumeLabel","oninput","value","Number","innerHTML","round","toString","dispatchEvent","Event","onchange","MouseEvent","checked","files","URL","createObjectURL","distortionLabel","loop","setTimeout","params","getByteTimeDomainData","getByteFrequencyData","translate","rotate","drawImage","width","height","total","length","calculateMean","globalAlpha","j","imageData","getImageData","data","random","red","green","blue","putImageData","window","onload","xhr","XMLHttpRequest","json","JSON","parse","responseText","console","log","AudioContext","filpathsMap","filepaths","tracksMap","songnames","dropdown","option","createElement","text","add","defaultsong","title","Audio","createMediaElementSource","createAnalyser","fftSize","numSamples","createGain","createBiquadFilter","type","createWaveShaper","connect","destination","analyserNodeRef","getContext","Uint8Array","Image","push","open","send"],"sourceRoot":""}